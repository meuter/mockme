#! /usr/bin/env python

import os
import sys
import optparse

from pycparser import parse_file, c_ast, c_generator

########################################################################################################################

class CModule(object):

    def __init__(self, filename, cpp_args=None):
        self.filename = filename
        self.cpp_args = cpp_args
        self.content  = None
        self.ast      = None
        
    def parse(self):
        self.content = open(self.filename, "r").read()            
        self.ast = parse_file(self.filename, use_cpp=True, cpp_args=self.cpp_args) 
    
    def get_name(self):
        _, module = os.path.split(self.filename)
        if (module.endswith(".c")): module = module.replace(".c","")
        if (module.endswith(".C")): module = module.replace(".C","")
        return module;
    
    def get_filename(self):
        return os.path.abspath(self.filename)
        
########################################################################################################################

class FunctionArgument(object):
    
    def __init__(self, name, declaration):
        self.name = name
        self.declaration = declaration
    
    def get_name(self):
        return self.name
    
    def get_declaration(self):
        return self.declaration

########################################################################################################################

class FunctionDefinition(object):
    
    def __init__(self, node):
        self.node = node
            
    def get_name(self):
        return self.node.decl.name

    def get_return_type(self):
        generator = c_generator.CGenerator()
        type_node = dict(dict(self.node.decl.children())['type'].children())['type']
        return_type_and_function_name = generator._generate_type(type_node)
        return return_type_and_function_name[:-len(self.get_name())].strip()
         
    def get_default_stub_arguments(self):
        # FIXME: use info provided in macro
        return_type = self.get_return_type()
        if   return_type == "void":  happy_value = "NULL";
        elif return_type == "rc_t": happy_value  = "RC_OK";
        else: happy_value = "happy_value"
        return happy_value  
         
    def get_arguments(self):
        generator = c_generator.CGenerator()
        args = dict(self.node.decl.type.children()).get('args', None)
        if not args: return []
    
        args = dict(args.children())
        result = []
        for arg in args.values():                    
            declaration = generator._generate_type(dict(arg.children())['type'])
            if arg.name: result.append(FunctionArgument(arg.name, declaration))
        return result                  
            
    def get_arguments_declaration(self):
        return ", ".join(arg.get_declaration() for arg in self.get_arguments())
    
    def get_file(self):
        return os.path.abspath(self.node.coord.file)
    
    def get_body(self):
        return dict(self.node.children()).get("body", None)
    
    def is_double(self):
        body = self.get_body()
        
        DOUBLE_MACROS = [
            "INPUT_VALUE", "INPUT_MEMORY", "INPUT_STRING",
            "OUTPUT_VALUE", "OUTPUT_MEMORY", "OUTPUT_STRING",
            "DEFAULT_STUB"
        ]
        
        for _, instruction in body.children():            
            if not isinstance(instruction, c_ast.FuncCall):
                return False
            called = instruction.name.name
            if called not in DOUBLE_MACROS:
                return False
                    
        return True
    
    def get_first_line(self):
        return self.node.decl.coord.line-1
    
    def get_body_range(self):
        body = self.get_body()
        _, last_instruction = body.children()[-1]
        _, first_instruction = body.children()[0]
        return range(first_instruction.coord.line-1, last_instruction.coord.line)
                
########################################################################################################################

class MockGenerator(object):
    
    def __init__(self, module, output):
        self.module = module
        self.output = output        

    def writeln(self, test):
        self.output.write(test + "\n")
        
    def write(self, text):
        self.output.write(text)

    def collect_double(self):
        result = []
                
        class Visitor(c_ast.NodeVisitor):
    
            def visit_FuncDef(self, node):
                func_def = FunctionDefinition(node)
                if func_def.is_double():
                     result.append(func_def)
                                
        Visitor().visit(self.module.ast)
        return result

    def generate_double_body(self, func_def):
        function_name        = func_def.get_name()
        return_type          = func_def.get_return_type()
        arguments            = func_def.get_arguments()
        happy_value          = func_def.get_default_stub_arguments()   
        return_or_not_return = "return " if return_type != "void" else ""
        
        self.writeln("    if (auto_stub())")
        self.writeln("        STUB_{function_name}({happy_value});".format(**locals())) 
        for arg in arguments:
            self.writeln("    check_expected({name});".format(name=arg.get_name()))
        self.writeln("    {return_or_not_return}({return_type})mock();".format(**locals()))              
        self.output.write("\n")        
        

    def generate_mock(self, func_def):
        self.output.write("// mock for %s\n" % func_def.get_name())
        self.output.write("\n")        
        
    def generate_stub(self, func_def):
        self.output.write("// stub for %s\n" % func_def.get_name())        
        self.output.write("\n")        

    def generate(self):                
        double_definitions = self.collect_double()
        
        line_map = {}        
        for double in double_definitions:
            for i in double.get_body_range():
                line_map[i] = double
            line_map[double.get_first_line()] = double

        lines  = self.module.content.splitlines()
        lineno = 0
        while lineno < len(lines):
            double = line_map.get(lineno, None)
            if double:            
                if lineno == double.get_first_line():
                    self.generate_stub(double)
                    self.generate_mock(double)
                    self.output.write(lines[lineno] + "\n")
                    lineno +=1                    
                elif lineno in double.get_body_range():
                    self.generate_double_body(double)
                    lineno = double.get_body_range()[-1]+1
            else: 
                self.output.write(lines[lineno] + "\n")
                lineno += 1
    

########################################################################################################################
  
""" OLD CODE:                     
            def gen_stub(self, func_def):
                return_type      = func_def.get_return_type()
                function_name    = func_def.get_function_name()
                arguments        = func_def.get_arguments()
                formal_arguments = return_type + " return_value" if return_type != "void" else ""
                return_value     = "return_value" if return_type != "void" else "NULL"
                
                lines.append("")
                lines.append("void STUB_{function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                for arg in arguments:
                    name = arg.get_name()
                    lines.append("    expect_any({function_name}, {name});".format(**locals()))
                lines.append("    will_return({function_name}, {return_value});".format(**locals()))
                lines.append("}")
                    
            
            def gen_mock(self, func_def):
                return_type      = func_def.get_return_type()
                function_name    = func_def.get_function_name()
                arguments        = func_def.get_arguments()
                formal_arguments = func_def.get_arguments_declaration()
                happy_value      = func_def.get_default_stub_arguments()   
                
                lines.append("void MOCK_{function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                for arg in arguments:
                    name = arg.get_name()
                    lines.append("    expect_value({function_name}, {name}, {name});".format(**locals()))
                lines.append("    will_return({function_name}, {happy_value});".format(**locals()))
                lines.append("}")
                    
"""
              
## CLI #################################################################################################################
    
def parse_args():
    parser = optparse.OptionParser(
        usage="%prog [options] <FILE>", 
        description="Automatically generates and add cmockery mocks/stubs/double functions to a C module"
    )

    parser.add_option("-I", action="append", default=[], dest="includes", metavar="<DIR>", 
                      help="Add the directory <DIR> to the list of directories to be searched for header files.")
    parser.add_option("-D", action="append", default=[], dest="defines", metavar="<NAME>", 
                      help="Predefine <NAME> as a macro, with definition 1")
    parser.add_option("-o", action="store", default=None, dest="output", metavar="<FILE>",
                      help="Sets <FILE> as output. Default is standard output")
    args, remaining = parser.parse_args()
        
    if len(remaining) != 1: 
        parser.print_help()
        sys.exit(-1)
        
    args.input  = remaining[0]
    args.output = open(args.output, "r") if args.output else sys.stdout
    args.cpp_args = [ 
        r"-nostdinc",
        r"-DMOCK_ME", 
    ]

    for dir in args.includes:
        args.cpp_args.append(r"-I" + dir)
    for name in args.defines:
        args.cpp_args.append(r"-D" + name)
    
    return args
    
         
########################################################################################################################
    
if __name__=="__main__":
    args = parse_args()
    module = CModule(args.input, cpp_args=args.cpp_args)
    module.parse()
    MockGenerator(module, args.output).generate()

#    module = CModule(args.input)

    
#    args = parse_args()
#
#    if (args.action == "prepare"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleDescriptionGenerator(module, args.output).generate()
#    elif (args.action == "mock"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleHeaderGenerator(module, args.output).generate()        
#    elif (args.action == "clone"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleHeaderGenerator(module).generate()
#        DoubleImplementationGenerator(module).generate()
