#! /usr/bin/env python

import os
import sys
import optparse

from pycparser import parse_file, c_ast, c_generator

########################################################################################################################

class CModule(object):
    """represents a C module that can be parsed"""

    @staticmethod
    def parse(filename, cpp_args=None):
        module = CModule(filename)
        module.do_parse(cpp_args)
        return module

    def __init__(self, filename):
        self.filename = filename
        self.content  = None
        self.ast      = None
        
    def do_parse(self, cpp_args=None):
        """pre-processes and then parses the module"""
        self.content = open(self.filename, "r").read()            
        self.ast = parse_file(self.filename, use_cpp=True, cpp_args=cpp_args) 
    
    def get_name(self):
        """returns the name of the module, i.e. the file name without extension"""
        _, module = os.path.split(self.filename)
        if (module.endswith(".c")): module = module.replace(".c","")
        if (module.endswith(".C")): module = module.replace(".C","")
        return module;
    
    def get_filename(self):
        """returns the absolute filename of the module""" 
        return os.path.abspath(self.filename)
    
    def get_lines(self):
        """returns a list containing the lines of the original module (before preprocessing)"""
        return self.content.splitlines()
    
    def get_function_definitions(self):
        """returns the list of function definitions as a list of FunctionDefinition"""
        result = []
        
        class Visitor(c_ast.NodeVisitor):
            def visit_FuncDef(self, node):
                result.append(FunctionDefinition(node))
                
        Visitor().visit(self.ast)
                    
        return result
    
########################################################################################################################

class FunctionCall(object):
    """represents a function call instructions"""
    
    def __init__(self, node):
        self.node = node;
        
    def get_called(self):
        """returns the function called as a string"""
        return self.node.name.name
    
    def get_actual_arguments(self):
        """returns the list of actual arguments as a list of string"""
        expr_list = dict(self.node.children()).get("args", None)
        if expr_list:
            generator = c_generator.CGenerator()
            return [ generator.visit(expr) for _, expr in expr_list.children() ]
        else:
            return []
        
    def get_actual_argument(self, n):
        """returns the n^th actual argument of a function call"""
        return self.get_actual_arguments()[n]
            

########################################################################################################################
       
class FunctionDefinition(object):
    """represents a function definition inside a C module"""
    
    def __init__(self, func_def_node):
        self.node = func_def_node
        self.formal_arguments = []
        self.parse_formal_arguments()
            
    def parse_formal_arguments(self):
        """parses the formal argument of the function and stores them in object"""
        args = dict(self.node.decl.type.children()).get('args', None)
        if not args: return 
            
        for _, arg_declaration in args.children():
            if 'type' in dict(arg_declaration.children()):
                self.formal_arguments.append(FunctionFormalArgument(arg_declaration))
        
    def get_name(self):
        """returns the name of the function being defined"""
        return self.node.decl.name

    def get_return_type(self):
        """returns the return type of the function as a string"""
        generator = c_generator.CGenerator()
        type_node = dict(dict(self.node.decl.children())['type'].children())['type']
        return_type_and_function_name = generator._generate_type(type_node)
        return return_type_and_function_name[:-len(self.get_name())].strip()
         
    def get_formal_arguments(self):   
        """returns the list of formal arguments of the function as a list of FunctionFormalArgument"""     
        return self.formal_arguments

    def get_formal_argument(self, name):
        """returns the argument corresponding to provided argument name as a FunctionFormalArgument"""
        for arg in self.get_formal_arguments():
            if arg.get_name() == name: 
                return arg
        return None

    def get_body(self):
        """returns the body of the function as a list of AST nodes"""
        body_node = dict(self.node.children()).get("body", None)
        if not body_node: return []
        return [ instruction for _, instruction in body_node.children() ]
    
    
    def get_declaration_line(self):
        """returns the list at which the function declaration is done withing its module"""
        return self.node.decl.coord.line-1
    
    def get_body_line_range(self):
        """returns a range of line number in the module of the body of the function""" 
        body = self.get_body()        
        return range(body[0].coord.line-1, body[-1].coord.line)
        
########################################################################################################################

class FunctionFormalArgument(object):
    """represents a formal argument in the a function definition"""
    
    def __init__(self, decl_node):
        self.node = decl_node
        self.tag_value = None
    
    def get_name(self):
        """returns the name of the argument as a string"""
        return self.node.name
    
    def get_type(self):
        """returns the type of the argument... well mostly does not work for [] types"""
        return self.get_declaration().replace(self.get_name(),"")
    
    def get_dereferenced_type(self):
        """returns the dereferenced type of the argument... well mostly does not work for [] types"""
        return self.get_dereferenced_declaration().replace(self.get_name(),"")
        
    def get_declaration(self):
        """returns the declaration of the argument as a string"""
        generator = c_generator.CGenerator()
        return generator._generate_type(dict(self.node.children())['type'])
    
    def get_dereferenced_declaration(self):
        """return a declaration of the argument with one less pointer indirection, e.g. 'int *p' --> 'int p'"""
        generator = c_generator.CGenerator()
        type_node = dict(self.node.children())['type']
        return generator._generate_type(self._deref_type_node(type_node))
          
    def _deref_type_node(self, type_node):
        """dereferences a type node, i.e. removes a PtrType at the root of the node"""
        return dict(type_node.children())['type']
            
    def tag(self, value):
        """allows to tag the argument"""
        self.tag_value = value
        
    def get_tag(self):
        """allows to retrieve the tag"""
        return self.tag_value 

########################################################################################################################

class DoubleDefinition(FunctionDefinition):
    """
    represents a double definition i.e. a classical function definition whose body is only composed of 
    macro call to INPUT_VALUE, INPUT_STRING, INPUT_MEMORY, OUTPUT_VALUE, OUTPUT_STRING, OUTPUT_MEMORY,
    or RETURN
    """
    
    DOUBLE_MACROS = [
            "INPUT_VALUE", "INPUT_MEMORY", "INPUT_STRING",
            "OUTPUT_VALUE", # "OUTPUT_MEMORY", "OUTPUT_STRING", not yet supported
            "RETURN"
    ]
    
    @staticmethod 
    def is_double(func_def):
        """checks if a function definition only contains macro calls to the macro detailed above"""
        for instruction in func_def.get_body():            
            if not isinstance(instruction, c_ast.FuncCall):
                return False
            called = instruction.name.name
            if called not in DoubleDefinition.DOUBLE_MACROS:
                return False                    
        return True
    
    def __init__(self, func_def):
        super(DoubleDefinition, self).__init__(func_def.node)
        self.return_statement = None        
        self.retrieve_return_statement()
        self.tag_arguments()
        
    def get_macro_calls(self, macro_prefix):
        """returns the list of macro calls matching a given prefix as a list of FunctionCall"""
        return [ FunctionCall(i) for i in self.get_body() if FunctionCall(i).get_called().startswith(macro_prefix) ]

    def retrieve_return_statement(self):
        """goes through the body of the double definition and looks for the RETURN() statement"""
        self.return_statement = self.get_macro_calls("RETURN")[0]
                
    def tag_arguments(self):
        """tags each formal argument with the macro call within the double definition body linked to that argument"""
        calls = self.get_macro_calls("INPUT_") + self.get_macro_calls("OUTPUT_")        
        for call in calls:
            formal_arg = self.get_formal_argument(call.get_actual_argument(0))
            if formal_arg: formal_arg.tag(call)            
                        
    def get_happy_return_value(self):
        """returns the default happy value of the double, i.e. the first argument of the RETURN macro call"""
        args = self.return_statement.get_actual_arguments()
        return args[0] if args else "NULL"
            
    def get_mock_formal_argument_declarations(self):
        """return the formal arguments declaration of the MOCK_foo function as a comma seperated string"""        
        return ", ".join(arg.get_declaration() for arg in self.get_formal_arguments() if not arg.get_tag().get_called().startswith("OUTPUT_"))
        
    def get_stub_default_actual_arguments(self):
        """returns the default stub argument as one comma separated string"""
        expression_list = []
        
        if self.return_statement.get_actual_arguments():
            expression_list.append(self.return_statement.get_actual_argument(0))

        for arg in self.get_formal_arguments():
            if arg.get_tag().get_called() == "OUTPUT_VALUE":
                expression_list.append(arg.get_tag().get_actual_argument(1))
                        
        return ", ".join(expression_list)
    
    def get_stub_formal_argument_declarations(self):
        """returns the formal arguments of the STUB_foo function as a comma seperated string"""
        declaration_list = []
    
        if self.get_return_type() != "void":
            declaration_list.append(self.get_return_type() + " return_value");

        for arg in self.get_formal_arguments():
            if arg.get_tag().get_called() == "OUTPUT_VALUE":
                declaration_list.append(arg.get_dereferenced_declaration())
            
        return ", ".join(declaration_list)
    
              
      
########################################################################################################################

class MockGenerator(object):
    
    def __init__(self, module, output):
        self.module = module
        self.output = output        

    def writeln(self, text=""):
        """writes some text followed by a new line to the output"""
        self.output.write(text + "\n")
        
    def collect_double(self):
        """collects all the double definition of the input module"""
        func_defs = self.module.get_function_definitions()
        return [ DoubleDefinition(func_def) for func_def in func_defs if DoubleDefinition.is_double(func_def) ] 

    def generate_double_body(self, double_def):
        """generates the code that goes inside the double function, hence replacing the double macro calls"""
        function_name        = double_def.get_name()
        return_type          = double_def.get_return_type()
        default_stub_args    = double_def.get_stub_default_actual_arguments()   
        return_or_not_return = "return " if return_type != "void" else ""
        
        self.writeln("    if (auto_stub())")
        self.writeln("        STUB_{function_name}({default_stub_args});".format(**locals()))
        for call in double_def.get_macro_calls("INPUT_"):
            if call.get_called() in [ "INPUT_VALUE", "INPUT_STRING" ]:
                name = call.get_actual_argument(0)
                self.writeln("    check_expected({name});".format(**locals()))
            elif call.get_called() == "INPUT_MEMORY":
                ptr = call.get_actual_argument(0)
                size = call.get_actual_argument(1)
                self.writeln("    check_expected({ptr});".format(**locals()))
        for call in double_def.get_macro_calls("OUTPUT_"):
            if call.get_called() == "OUTPUT_VALUE":
                name = call.get_actual_argument(0)
                type = double_def.get_formal_argument(name).get_dereferenced_type()
                self.writeln("    check_expected({name});".format(**locals()))
                self.writeln("    *({name}) = ({type})mock();".format(**locals()))
                
            
        self.writeln("    {return_or_not_return}({return_type})mock();".format(**locals()))
    
    
    def generate_mock(self, double_def):
        """generates the MOCK_foo function"""
        function_name    = double_def.get_name()
        formal_arguments = double_def.get_mock_formal_argument_declarations()
        happy_value      = double_def.get_happy_return_value()
        
        self.writeln("void MOCK_{function_name}({formal_arguments})".format(**locals()))
        self.writeln("{")
        for call in double_def.get_macro_calls("INPUT_"):
            if call.get_called() == "INPUT_VALUE":
                value = call.get_actual_argument(0)
                self.writeln("    expect_value({function_name}, {value}, {value});".format(**locals()))
            elif call.get_called() == "INPUT_STRING":
                value = call.get_actual_argument(0)
                self.writeln("    expect_string({function_name}, {value}, {value});".format(**locals()))
            elif call.get_called() == "INPUT_MEMORY":
                ptr = call.get_actual_argument(0)
                size = call.get_actual_argument(1)
                self.writeln("    expect_memory({function_name}, {ptr}, {ptr}, {size});".format(**locals()))
        for call in double_def.get_macro_calls("OUTPUT_"):
            if call.get_called() == "OUTPUT_VALUE":
                name = call.get_actual_argument(0)
                default_value = call.get_actual_argument(1)
                self.writeln("    expect_not_value({function_name}, {name}, NULL);".format(**locals()))
                self.writeln("    will_return({function_name}, {default_value});".format(**locals()))

        self.writeln("    will_return({function_name}, {happy_value});".format(**locals()))                
        self.writeln("}")    
        self.writeln()    
        
    def generate_stub(self, double_def):
        """generates the STUB_foo function"""
        return_type      = double_def.get_return_type()
        function_name    = double_def.get_name()
        formal_arguments = double_def.get_stub_formal_argument_declarations()
        return_value     = "return_value" if return_type != "void" else "NULL"
                
        self.writeln("")
        self.writeln("void STUB_{function_name}({formal_arguments})".format(**locals()))
        self.writeln("{")
        for call in double_def.get_macro_calls("INPUT_"):
            if call.get_called() in [ "INPUT_VALUE", "INPUT_STRING" ]:
                name = call.get_actual_argument(0)
                self.writeln("    expect_any({function_name}, {name});".format(**locals()))
            elif call.get_called() == "INPUT_MEMORY":
                ptr = call.get_actual_argument(0)
                size = call.get_actual_argument(1)
                self.writeln("    expect_any({function_name}, {ptr});".format(**locals()))
        for call in double_def.get_macro_calls("OUTPUT_"):
            if call.get_called() == "OUTPUT_VALUE":
                name = call.get_actual_argument(0)
                self.writeln("    expect_not_value({function_name}, {name}, NULL);".format(**locals()))
                self.writeln("    will_return({function_name}, {name});".format(**locals()))
                                

        self.writeln("    will_return({function_name}, {return_value});".format(**locals()))
        self.writeln("}")
        self.writeln()        

    def generate(self):
        """
        This is where all the magic happens. The un-pre-processed module is transformed as follows:
            - before any double definition foo(), two additional function MOCK_foo() and STUB_foo() are added
              with appropriate cmockery code (expect_any, expect_value, expect_stirng, expect_memory, ...)
            - the body of the double function is replaced with correct cmockery code (check_expected(), mock(), ...)
            - all other lines are copied through untouched
        """
        double_definitions = self.collect_double()
        
        line_map = {}        
        for double in double_definitions:
            for i in double.get_body_line_range():
                line_map[i] = double
            line_map[double.get_declaration_line()] = double

        lines  = self.module.get_lines()
        lineno = 0
        while lineno < len(lines):
            double = line_map.get(lineno, None)
            if double:            
                if lineno == double.get_declaration_line():
                    self.generate_stub(double)
                    self.generate_mock(double)
                    self.writeln(lines[lineno])
                    lineno +=1                    
                elif lineno in double.get_body_line_range():
                    self.generate_double_body(double)
                    lineno = double.get_body_line_range()[-1]+1
            else: 
                self.writeln(lines[lineno])
                lineno += 1
           
########################################################################################################################
    
def parse_args():
    """parses the command line argument, see 'mockme --help' for details"""
    parser = optparse.OptionParser(
        usage="%prog [options] <INFILE>", 
        description="Automatically generates and add cmockery mocks/stubs/double functions to a C module"
    )

    parser.add_option("-I", action="append", default=[], dest="includes", metavar="<DIR>", 
                      help="add the directory <DIR> to the list of directories to be searched for header files.")
    parser.add_option("-D", action="append", default=[], dest="defines", metavar="<NAME>", 
                      help="predefine <NAME> as a macro, with definition 1")
    parser.add_option("-o", action="store", default=None, dest="output", metavar="<OUTFILE>",
                      help="sets <OUTFILE> as output; if no file is provided, the standard output will be used")
    args, remaining = parser.parse_args()
        
    if len(remaining) != 1: 
        parser.print_help()
        sys.exit(-1)
        
    args.input  = remaining[0]
    args.output = open(args.output, "w") if args.output else sys.stdout
    args.cpp_args = [ 
        r"-nostdinc",
        r"-DMOCK_ME",
        r"-DUNDER_TEST" 
    ]

    for dir in args.includes:
        args.cpp_args.append(r"-I" + dir)
    for name in args.defines:
        args.cpp_args.append(r"-D" + name)
    
    return args
    
########################################################################################################################
    
if __name__=="__main__":
    args = parse_args()
    MockGenerator(CModule.parse(args.input, args.cpp_args), args.output).generate()

