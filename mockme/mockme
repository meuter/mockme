#! /usr/bin/env python

import os
import sys
import optparse

from pycparser import parse_file, c_ast, c_generator

########################################################################################################################

class CModule(object):

    def __init__(self, filename, cpp_args=None):
        self.filename = filename
        self.cpp_args = cpp_args
        self.content  = None
        self.ast      = None
        
    def parse(self):
        self.content = open(self.filename, "r").read()            
        self.ast = parse_file(self.filename, use_cpp=True, cpp_args=self.cpp_args) 
    
    def get_name(self):
        _, module = os.path.split(self.filename)
        if (module.endswith(".c")): module = module.replace(".c","")
        if (module.endswith(".C")): module = module.replace(".C","")
        return module;
    
    def get_filename(self):
        return os.path.abspath(self.filename)
        
########################################################################################################################

class FunctionArgument(object):
    
    def __init__(self, name, declaration):
        self.name = name
        self.declaration = declaration
    
    def get_name(self):
        return self.name
    
    def get_declaration(self):
        return self.declaration

########################################################################################################################

class FunctionDefinition(object):
    
    def __init__(self, node):
        self.node = node
            
    def get_name(self):
        return self.node.decl.name

    def get_return_type(self):
        generator = c_generator.CGenerator()
        type_node = dict(dict(self.node.decl.children())['type'].children())['type']
        return_type_and_function_name = generator._generate_type(type_node)
        return return_type_and_function_name[:-len(self.get_function_name())].strip()
         
    def get_happy_return_value(self):
        return_type = self.get_return_type()
        if   return_type == "void":  happy_value = "NULL";
        elif return_type == "rc_t": happy_value  = "RC_OK";
        else: happy_value = "happy_value"
        return happy_value  
         
    def get_arguments(self):
        generator = c_generator.CGenerator()
        args = dict(self.node.decl.type.children()).get('args', None)
        if not args: return []
    
        args = dict(args.children())
        result = []
        for arg in args.values():                    
            declaration = generator._generate_type(dict(arg.children())['type'])
            if arg.name: result.append(FunctionArgument(arg.name, declaration))
        return result                  
            
    def get_arguments_declaration(self):
        return ", ".join(arg.get_declaration() for arg in self.get_arguments())
    
    def get_file(self):
        return os.path.abspath(self.node.coord.file)
    
    def get_body(self):
        return dict(self.node.children()).get("body", None)
    
    def is_double(self):
        body = self.get_body()
        
        DOUBLE_MACROS = [
            "INPUT_VALUE", "INPUT_MEMORY", "INPUT_STRING",
            "OUTPUT_VALUE", "OUTPUT_MEMORY", "OUTPUT_STRING",
            "DEFAULT_STUB"
        ]
        
        for _, instruction in body.children():            
            if not isinstance(instruction, c_ast.FuncCall):
                return False
            called = instruction.name.name
            if called not in DOUBLE_MACROS:
                return False
                    
        return True
    
    def get_first_line(self):
        return self.node.decl.coord.line-1
    
    def get_body_range(self):
        body = self.get_body()
        _, last_instruction = body.children()[-1]
        _, first_instruction = body.children()[0]
        return range(first_instruction.coord.line-1, last_instruction.coord.line)
                
########################################################################################################################

class MockGenerator(object):
    
    def __init__(self, module, output):
        self.module = module
        self.output = output        


    def collect_double(self):
        result = []
                
        class Visitor(c_ast.NodeVisitor):
    
            def visit_FuncDef(self, node):
                func_def = FunctionDefinition(node)
                if func_def.is_double():
                     result.append(func_def)
                                
        Visitor().visit(self.module.ast)
        return result

    def generate_double(self, func_def):
        self.output.write("    // double body for %s\n" % func_def.get_name())        
        self.output.write("\n")        

    def generate_mock(self, func_def):
        self.output.write("// mock for %s\n" % func_def.get_name())
        self.output.write("\n")        
        
    def generate_stub(self, func_def):
        self.output.write("// stub for %s\n" % func_def.get_name())        
        self.output.write("\n")        

    def generate(self):                
        double_definitions = self.collect_double()
        
        line_map = {}        
        for double in double_definitions:
            for i in double.get_body_range():
                line_map[i] = double
            line_map[double.get_first_line()] = double

        lines  = self.module.content.splitlines()
        lineno = 0
        while lineno < len(lines):
            double = line_map.get(lineno, None)
            if double:            
                if lineno == double.get_first_line():
                    self.generate_stub(double)
                    self.generate_mock(double)
                    self.output.write(lines[lineno] + "\n")
                    lineno +=1                    
                elif lineno in double.get_body_range():
                    self.generate_double(double)
                    lineno = double.get_body_range()[-1]+1
            else: 
                self.output.write(lines[lineno] + "\n")
                lineno += 1
        


########################################################################################################################
"""    
class DoubleDescriptionGenerator(Generator):
    
    def __init__(self, module, output=None):
        output = output if output else "%s_mock.c" % module.get_name()
        super(DoubleDescriptionGenerator, self).__init__(module, output)
        
    def gen_header(self, lines):
        lines.append("#ifndef __ADYTON_%s_MOCK_H__" % self.module.get_name().upper())
        lines.append("#define __ADYTON_%s_MOCK_H__" % self.module.get_name().upper())        
        lines.append("")
        lines.append("#include <adyton/mock/mock.h>")

        for line in self.module.content.splitlines():
            if line.strip().startswith("#"):
                lines.append(line)
               
    def gen_body(self, lines):
        
        module = self.module
        
        class Visitor(c_ast.NodeVisitor):
            
            def gen_double_description(self, func_def):
                return_type      = func_def.get_return_type()
                function_name    = func_def.get_function_name()
                arguments        = func_def.get_arguments()
                formal_arguments = func_def.get_arguments_declaration()
                happy_value      = func_def.get_happy_return_value()                
                                
                lines.append("")
                lines.append("{return_type} {function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                for arg in arguments:
                    lines.append("    INPUT_VALUE({name});".format(name=arg.get_name()))
                lines.append("    RETURN_VALUE({happy_value});".format(**locals()))
                lines.append("}")
                
            def visit_FuncDef(self, node):
                func_def = FunctionDefinition(node)                                      
                if (func_def.get_function_name() == "main"):   return
                if (func_def.get_file() != module.get_file()): return                                
                self.gen_double_description(func_def)
               
        Visitor().visit(self.module.ast)
        
    def gen_footer(self, lines):
        lines.append("")
        lines.append("#endif")           
        lines.append("")

########################################################################################################################
    
class DoubleHeaderGenerator(Generator):
    
    def __init__(self, module, output=None):
        output = output if output else "%s_mock.h" % module.get_name()
        super(DoubleHeaderGenerator, self).__init__(module, output)
        
    def gen_header(self, lines):
        lines.append("#ifndef __ADYTON_%s_MOCK_H__" % self.module.get_name().upper())
        lines.append("#define __ADYTON_%s_MOCK_H__" % self.module.get_name().upper())        
        lines.append("")

        for line in self.module.content.splitlines():
            if line.strip().startswith("#"):
                lines.append(line)
               
    def gen_body(self, lines):
        
        module = self.module
        
        class Visitor(c_ast.NodeVisitor):
            
            def gen_declaration(self, func_def):
                return_type           = func_def.get_return_type()
                function_name         = func_def.get_function_name()
                formal_arguments      = func_def.get_arguments_declaration()
                mock_formal_arguments = func_def.get_arguments_declaration()
                stub_formal_arguments = return_type + " return_value" if return_type != "void" else ""
                                
                lines.append("")
                lines.append("void MOCK_{function_name}({mock_formal_arguments});".format(**locals()))
                lines.append("void STUB_{function_name}({stub_formal_arguments});".format(**locals()))
                lines.append("{return_type} UNDER_TEST_{function_name}({formal_arguments});".format(**locals()))            
            
            def visit_FuncDef(self, node):
                func_def = FunctionDefinition(node)
                if (func_def.get_function_name() == "main"): return
                if (func_def.get_file() != module.get_file()): return               
                self.gen_declaration(func_def)
               
        Visitor().visit(self.module.ast)
        
    def gen_footer(self, lines):
        lines.append("")
        lines.append("#endif")           
        lines.append("")

########################################################################################################################
  
class DoubleImplementationGenerator(Generator):

    def __init__(self, module, output=None):
        output = output if output else "%s_mock.c" % module.get_name()
        super(DoubleImplementationGenerator, self).__init__(module, output)
        
    def gen_header(self, lines):
        lines.append("#include <adyton/mock/%s_mock.h>" % self.module.get_name())
        lines.append("#include <adyton/test/unit_test.h>")
    
    def gen_body(self, lines):

        module = self.module    
        
        class ImplementationVisitor(c_ast.NodeVisitor):
                
            def gen_separator(self):
                lines.append("") 
                lines.append("/" + "*"*118 + "/")
                            
            def gen_stub(self, func_def):
                return_type      = func_def.get_return_type()
                function_name    = func_def.get_function_name()
                arguments        = func_def.get_arguments()
                formal_arguments = return_type + " return_value" if return_type != "void" else ""
                return_value     = "return_value" if return_type != "void" else "NULL"
                
                lines.append("")
                lines.append("void STUB_{function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                for arg in arguments:
                    name = arg.get_name()
                    lines.append("    expect_any({function_name}, {name});".format(**locals()))
                lines.append("    will_return({function_name}, {return_value});".format(**locals()))
                lines.append("}")
                    
            
            def gen_mock(self, func_def):
                return_type      = func_def.get_return_type()
                function_name    = func_def.get_function_name()
                arguments        = func_def.get_arguments()
                formal_arguments = func_def.get_arguments_declaration()
                happy_value      = func_def.get_happy_return_value()   
                
                lines.append("void MOCK_{function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                for arg in arguments:
                    name = arg.get_name()
                    lines.append("    expect_value({function_name}, {name}, {name});".format(**locals()))
                lines.append("    will_return({function_name}, {happy_value});".format(**locals()))
                lines.append("}")
                    
            def gen_double(self, func_def): 
                return_type          = func_def.get_return_type()
                function_name        = func_def.get_function_name()
                arguments            = func_def.get_arguments()
                formal_arguments     = func_def.get_arguments_declaration()
                happy_value          = func_def.get_happy_return_value()   
                return_or_not_return = "return " if return_type != "void" else ""
                
                lines.append("")
                lines.append("{return_type} {function_name}({formal_arguments})".format(**locals()))
                lines.append("{")
                lines.append("    if (default_stub())")
                lines.append("        STUB_{function_name}({happy_value});".format(**locals()))
                for arg in arguments:
                    lines.append("    check_expected({name});".format(name=arg.get_name()))
                lines.append("    {return_or_not_return}({return_type})mock();".format(**locals()))
                lines.append("}")

            def visit_FuncDef(self, node):
                func_def = FunctionDefinition(node)
                if (func_def.get_function_name() == "main"): return
                if (func_def.get_file() != module.get_file()): return               
                self.gen_separator()
                self.gen_stub(func_def)
                self.gen_mock(func_def)
                self.gen_double(func_def)

        visitor = ImplementationVisitor()
        visitor.visit(self.module.ast)
    
    def gen_footer(self, lines):
        lines.append("")
"""
              
## CLI #################################################################################################################
    
def parse_args():
    parser = optparse.OptionParser(
        usage="%prog [options] <FILE>", 
        description="Automatically generates and add cmockery mocks/stubs/double functions to a C module"
    )

    parser.add_option("-I", action="append", default=[], dest="includes", metavar="<DIR>", 
                      help="Add the directory <DIR> to the list of directories to be searched for header files.")
    parser.add_option("-D", action="append", default=[], dest="defines", metavar="<NAME>", 
                      help="Predefine <NAME> as a macro, with definition 1")
    parser.add_option("-o", action="store", default=None, dest="output", metavar="<FILE>",
                      help="Sets <FILE> as output. Default is standard output")
    args, remaining = parser.parse_args()
        
    if len(remaining) != 1: 
        parser.print_help()
        sys.exit(-1)
        
    args.input  = remaining[0]
    args.output = open(args.output, "r") if args.output else sys.stdout
    args.cpp_args = [ 
        r"-nostdinc",
        r"-DMOCK_ME", 
    ]

    for dir in args.includes:
        args.cpp_args.append(r"-I" + dir)
    for name in args.defines:
        args.cpp_args.append(r"-D" + name)
    
    return args
    
         
########################################################################################################################
    
if __name__=="__main__":
    args = parse_args()
    module = CModule(args.input, cpp_args=args.cpp_args)
    module.parse()
    MockGenerator(module, args.output).generate()

#    module = CModule(args.input)

    
#    args = parse_args()
#
#    if (args.action == "prepare"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleDescriptionGenerator(module, args.output).generate()
#    elif (args.action == "mock"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleHeaderGenerator(module, args.output).generate()        
#    elif (args.action == "clone"):
#        module = CModule(args.file)
#        module.parse()
#        DoubleHeaderGenerator(module).generate()
#        DoubleImplementationGenerator(module).generate()
